--
--выполнение программы на гетерогенном поле вычислителей 
--оптимизированный вариант 03 (апрель 2017)
--============================================================
--
--projectName = "squa_equ_2"  -- им€ проекта 
--projectName = "squa_equ_2.pred"
--
--projectName = "max-1_mass-8.pred"
--projectName = "max-2_mass-8.pred"
--
--projectName = "slau_2"
--projectName = "slau_3"
--projectName = "slau_4" 
--projectName = "slau_5"
--projectName = "slau_7"
--projectName = "slau_10"
--
--projectName = "doubling_32"
--
--projectName = "m_matr_2"
--projectName = "m_matr_3"
--projectName = "m_matr_5"
--projectName = "m_matr_7"
projectName = "m_matr_10"
--
--projectName = "m_matr_vec_2"
--projectName = "m_matr_vec_3"
--projectName = "m_matr_vec_5"
--projectName = "m_matr_vec_7"
--projectName = "m_matr_vec_10"
--
--projectName = "fibonn_10"
--projectName = "tribonn_10"
--projectName = "quadronn_10"
--
--projectName = "mnk_5"
--projectName = "mnk_10"
--projectName = "mnk_15"
--projectName = "mnk_20"
--
--projectName = "mnk-2_5"
--projectName = "mnk-2_10"
--projectName = "mnk-2_15"
--projectName = "mnk-2_20"
--
--projectName = "korr_5" 
--projectName = "korr_10"
--projectName = "korr_15"
--projectName = "korr_20"
--
--projectName = "e17_o11_t6"
--projectName = "e313_o206_t32"
--projectName = "e2367_o1397_t137"
--projectName = "e451_o271_t30"
--projectName = "e916_o624_t89" 
--projectName = "e17039_o9853_t199"
--
--
-- *** начинаем с ѕќƒѕ–ќ√–јћћ (functions) *****************************************************************
--
--
function RenumbRandOps() -- переименовать ќѕ≈–ј“ќ–џ в случайном пор€дке
-- функци€ выполн€тьс€ может только после построени€ яѕ‘ и копировани€ еЄ в Lua-таблицу Tiers[][]
local iTier, jTier, i, j, iOp, newOp, flag
local maxOp=0 -- максимальный номер оператора
local K=1e6 -- диапазон сдвига номеров операторов при преобразовании (10^6)
local M=1 -- расширение диапазона нумерации при преобразовании (при M=1 диапазон номеров ќѕ≈–ј“ќ–ќ¬ неизменен... но ƒќЋ√ќ!)
local out1, out2
local n=0
--
math.randomseed( os.time() ) -- инициализаци€ math.random 
--
for iTier=1,#Tiers do -- по всем €русам яѕ‘
 for jTier=1,#Tiers[iTier] do -- цикл по ќѕ≈–ј“ќ–јћ на данном €русе
  if Tiers[iTier][jTier] >= maxOp then
   maxOp = Tiers[iTier][jTier] -- ищем max (Tiers[iTier][jTier] = iOp)
end end end -- конец if и обоих for
--
for iTier=1,#Tiers do -- по всем €русам яѕ‘
 for jTier=1,#Tiers[iTier] do -- цикл по ќѕ≈–ј“ќ–јћ на данном €русе
  iOp = Tiers[iTier][jTier] -- запомнили "старый" номер оператора 
--
::cont_rand::
--
  newOp = K + math.random( 1, M * maxOp ) -- "новый" номер оператора (пробный)
--
flag = 0 -- нет ли оператора newOp в списке ?
for i=1,#Tiers do -- по всем €русам яѕ‘
 for j=1,#Tiers[i] do -- цикл по ќѕ≈–ј“ќ–јћ на данном €русе
  if newOp == Tiers[i][j]  then -- номер newOp уже существует...
   flag = 1 -- установим флаг
end end end -- конец for i, for j и if newOp
--
if flag ~= 0 then -- если newOp уже присутствует...
 n=n+1 -- суммируем число "промахов" math.random
 AddLineToTextFrame( "промах: " .. n ) -- выводим число промахов
 goto cont_rand -- идЄм на генерацию нового значени€ newOp
end -- конец if flag
--
for i=1,#Tiers do -- по всем €русам яѕ‘
 for j=1,#Tiers[i] do -- цикл по ќѕ≈–ј“ќ–јћ на данном €русе
  if Tiers[i][j] == iOp then -- номер оператора 
   Tiers[i][j] = newOp -- "новый" номер оператора
end end end -- конец for i, for j и if Tiers[i][j]
--
end end -- конец for iTier=1,#Tiers и for jTier=1,#Tiers[iTier] (самые внешние )
--
for iTier=1,#Tiers do -- по всем €русам яѕ‘
 out1 = string.format("[RenumbRandOps] %d/%d: ", iTier, #Tiers[iTier] )
 for jTier=1,#Tiers[iTier] do -- цикл по ќѕ≈–ј“ќ–јћ на данном €русе
  Tiers[iTier][jTier] = Tiers[iTier][jTier] - K -- восстанавливаем номер оператора в диапазоне [1-maxOp]
  out1 = out1 .. string.format("%d ", Tiers[iTier][jTier] )
end  -- конец for jTier 
 AddLineToTextFrame( out1 )
end -- конец for iTier=1,#Tiers 
end -- *** конец функции RenumbRandOps()  ****************************************************************
--
--
--
function FindCalcByOp( iOp ) -- определение ¬џ„»—Ћ»“≈Ћя дл€ данной ќѕ≈–ј÷»»
local CalcOnCountOps = {} -- 2D-массив "номера ¬џ„»—Ћ»“≈Ћ≈… - число исполн. ќѕ≈–ј“ќ–ќ¬"
local OpsCalcs = OpsCalcs -- локальна€ копи€ глобальной OpsOnCalcs[][]
local nCalcs = nCalcs -- то же...
local jCalc, Calc, j,  i 
local minOpsCalc = 1e9 -- math.huge не работает!!!
--
CalcOnCountOps[1] = {} -- создаЄм строку 1
CalcOnCountOps[2] = {} -- создаЄм строку 2
--
for jCalc=1,nCalcs do -- по всем ¬џ„»—Ћ»“≈Ћяћ
 if CanExecOpCalc( iOp, jCalc ) > 0 then -- можно выполнить
  table.insert( CalcOnCountOps[1],  jCalc ) -- добавили в 1-ю строку массива CalcOnCountOps[][]
  table.insert( CalcOnCountOps[2],  0 ) -- 2-ю строку заполн€ем нул€ми дл€ последующего суммировани€ числа ќѕ≈–ј“ќ–ќ¬
--  AddLineToTextFrame( string.format("-> iOp=%d  1-row=%d  2-row=%d",  iOp, CalcOnCountOps[ 1 ][ jCalc ], CalcOnCountOps[ 2 ][ jCalc ] ))
 end -- конец if CanExecOpCalc( iOp, jCalc )
end -- конец for jCalc=1,nCalcs
--  AddLineToTextFrame( string.format("-> длина CalcOnCountOps[1/2]=%d/%d",  #CalcOnCountOps[1], #CalcOnCountOps[2] ))
--
-- в строке CalcOnCountOps[2][х]  запоминаем число ќѕ≈–ј“ќ–ќ¬, уже распределЄнных этому ¬џ„»—Ћ»“≈Ћё
for j=1,#CalcOnCountOps[1] do -- по колонкам массива CalcOnCountOps[1][х]
 jCalc = CalcOnCountOps[1][j] -- ¬џ„»—Ћ»“≈Ћ№ номер jCalc
-- считаем число уже распределенных ќѕ≈–ј“ќ–ќ¬ дл€ каждого из ¬џ„»—Ћ»“≈Ћ≈…
 for i=1,#OpsCalcs do -- по числу строк 2D-массива OpsCalcs
  if OpsCalcs[i][jCalc] ~= 0 then -- если –ј—ѕ–≈ƒ≈Ћ≈Ќќ (т.е. не 0)...
   CalcOnCountOps[2][j] = CalcOnCountOps[2][j] + 1 -- прибавили...
  end -- конец if OpsCalcs[i][jCalc]
 end -- конец for i=1,#OpsCalcs 
--
-- ищем ¬џ„»—Ћ»“≈Ћ№ с min распред. ему ќѕ≈–ј“ќ–ќ¬ (минимум CalcOnCountOps[2][j] по jCalc)
-- AddLineToTextFrame( string.format("=> j=%d CalcOnCountOps[2][j]=%d minOpsCalc=%d", j, CalcOnCountOps[2][j], minOpsCalc ))
 if CalcOnCountOps[2][j] < minOpsCalc then -- ...первый встреченный минимум
-- if CalcOnCountOps[2][j] <= minOpsCalc then -- ...последний встреченный минимум 
  minOpsCalc = CalcOnCountOps[2][j]
  Calc = CalcOnCountOps[1][j]
 end -- конец if CalcOnCountOps[2][j]
--
end -- конец for j=1,#CalcOnCountOps[1]
--==============================================================
--out1=" Calc:  "
--out2="#Calc: "
--for j=1,#CalcOnCountOps[1] do
-- out1=out1..string.format("%04d ", CalcOnCountOps[1][j] )
-- out2=out2..string.format("%04d ", CalcOnCountOps[2][j] )
--end 
--AddLineToTextFrame( "\n#Op= "..iOp.." #Calcs= "..#CalcOnCountOps[1] )
--AddLineToTextFrame( out1 )
--AddLineToTextFrame( out2 )
--==============================================================
CalcOnCountOps = nil -- уничтожили массив
--
--AddLineToTextFrame( string.format("==  FindCalcByOp() вернул= %d ==", Calc))
--AddLineToTextFrame( string.format("==  FindCalcByOp() вернул= %d / %d ==", minOpsCalc,Calc))
--
 return Calc -- вернули рекомендуемый номер ¬џ„»—Ћ»“≈Ћя дл€ iOp
end -- *** конец функции FindCalcByOp() *************************************************************
--
--
-- 
function CopyTiersInLua() -- рассчитанные CreateTiersByEdges() данные по яѕ‘ копируем в массив Tiers[][]
-- функци€ может выполн€тьс€ только после API-вызова CreateTiersByEdges()
local iTier, nOp
local Tiers = {} -- таблица (список операторов) по €русам (пока локальна€)
for iTier=1,GetCountTiers() do -- по €русам яѕ‘
 Tiers[ iTier ] = {} -- создаЄм строку 2D-массива
 for nOp=1,GetCountOpsOnTier( iTier ) do -- по пор€дковым номерам операторов на €русе iTier  
  Tiers[ iTier ][ nOp ] = GetOpByNumbOnTier( nOp, iTier ) -- вз€ть номер оператора
 -- AddLineToTextFrame ( string.format("#Tier=%d nOp=%d #Op=%d", iTier, nOp, Tiers[iTier][nOp] ) )  -- данные об €русе
end end -- конец for по iTier и for по nOp
--
return Tiers -- вернЄм заполненный Tiers[][]
--
end -- *** конец функции —opyTiersInLua() ********************************************************************
--
--
--
function Fun( i )
 print("-- ¬ызвана функци€ Fun(" .. i .. ") --")
 OutLine("\n-- Lua: ¬ызвана функци€ Fun(" .. i .. ") ")
 sleep( 10 )
end
--
function sleep(ms) 
 local start = os.clock() * 1000 
 while os.clock() * 1000 - start <= ms do end 
end 
----------------------------------------------------------------------------------------------------------------------------------------------
--=== ѕ–ќ√–јћћј MAIN =========================================================
----------------------------------------------------------------------------------------------------------------------------------------------
--
ClearTextFrame() -- очистка тестового экрана
--
LoadFileNameParamsOps( projectName .. ".ops" )     
LoadFileNameParamsCalcs( projectName .. ".cls" )   
LoadFileNameParamsEdges( projectName .. ".med" )                                                                                      
LoadFileNameParamsVertices( projectName .. ".mvr" )
--
--LuaCallByTimer( 5, "A_04(); SoundPlay('cuckoo.wav');") --------------------------------------------------------------------------------------
--LuaCallByTimer(15, "A_03(); SoundPlay('goodbye.wav');") --------------------------------------------------------------------------------------
--LuaCallByTimer(10, "A_01(); SoundPlay('pig.wav');") --------------------------------------------------------------------------------------
--LuaCallByTimer(25, "A_02(); SoundPlay('rooster.wav');") --------------------------------------------------------------------------------------
--LuaCallByTimer(30, "A_05(); SoundPlay('dog1.wav');") --------------------------------------------------------------------------------------
--
for i=1,10000 do -- по по вызовам LuaCallByTimer
 LuaCallByTimer(i, "Fun(" .. i .. ");") --------------------------------------------------------------------------------------
end
--
AddLineToTextFrame( "ћетрика = " .. GetMetricOpByName(120, "Times") )
--
PutParamsAll() -- вывод »—’ќƒЌџ’ и — ќ––≈ “»–ќ¬јЌЌџ’ параметров настройки
--
AddLineToTextFrame ( "\n=== ¬џ„»—Ћ»“≈Ћ» === " )
AddLineToTextFrame ( "¬сего вычислителей= " .. GetCountCalcs() ) 
--
ReadEdges(  projectName .. ".gv" )  -- читаем файл описани€ графа
--[[
AddLineToTextFrame("\n\n¬ыполнение TestCanExecAllOpsCalcs() может зат€нутьс€... ∆дЄм-с !\n")
if ( not TestCanExecAllOpsCalcs( 0 ) )  then -- проверка выполн»мости ќѕ≈–ј“ќ–ќ¬ на ¬џ„»—Ћ»“≈Ћя’ 
 AddLineToTextFrame ( "\n...ѕроблемы с выполнимостью ќѕ≈–ј“ќ–ќ¬ на ¬џ„»—Ћ»“≈Ћя’..." )
  return
end 
--]]
AddLineToTextFrame ( "\n=== ќѕ≈–ј“ќ–џ ===" )
AddLineToTextFrame ( "¬сего операторов= " .. GetCountOps() )
--
nCalcs = GetCountCalcs() -- всего ¬џ„»—Ћ»“≈Ћ≈…
--
--PutEdgesToTextFrame() -- вывод файла дуг »√ј
--
CreateTiersByEdges(  projectName .. ".gv" ) -- создать яѕ‘ по »√ј
PutTiersToTextFrame() -- вывести яѕ‘ как текст
ClearDiagrTiers() -- очистить поле графики
DrawDiagrTiers() -- вывести яѕ‘ в виде линейной диаграммы
------------------------------------------------------------------------------------------------------------------------ 
Tiers = {} -- глобальный 2D-массив яѕ‘ в пам€ти Lua
Tiers = CopyTiersInLua() -- вычисл€ем по данным CreateTiersByEdges()
------------------------------------------------------------------------------------------------------------------------
--RenumbRandOps() -- случайна€ перенумераци€ операторов
------------------------------------------------------------------------------------------------------------------------
--
totalSubTiers = 0 -- общее число подъ€русов
--
nTiers = #Tiers -- общее число €русов в яѕ‘
--
calcsUsedAll = 0 -- сколько вычислителей задействовано вообще (на всех €русах, доли единицы) 
--
--=== Ќј»ЅќЋ≈≈ ¬Ќ≈ЎЌ»… ÷» Ћ - по номеру €руса первичной яѕ‘ ================
for iTier=1,nTiers do -- цикл по €русам яѕ‘ (по iTier) ######################################
--
 OpsCalcs = {} -- создали список (фактически 1-й столбец будущего 2D-массива)
--
 subTiers = 1 -- имеем один ѕќƒЏя–”— на €русе iTier 
 OpsCalcs[ subTiers ] = {} -- создали строку номер subTiers (номер подъ€руса)
--
 for jCalc=1,nCalcs do -- по всем столбцам-¬џ„»—Ћ»“≈Ћяћ
  OpsCalcs[ subTiers ][ jCalc ] = 0 -- ноль = ¬џ„»—Ћ»“≈Ћё jCalc не распределены ќѕ≈–ј“ќ–џ
 end -- конец for jCalc=1,nCalcs
--
 nOps = #Tiers[ iTier ]  -- число операторов на €русе iTier
 for nOp=1,nOps do -- номер оператора на €русе
  iOp = Tiers[ iTier ][ nOp ] -- собственно номер ќѕ≈–ј“ќ–ј 
--
 mCalc = FindCalcByOp( iOp ) -- определили номер ¬џ„»—Ћ»“≈Ћя дл€ ќѕ≈–ј“ќ–ј iOp
--
-- можно ли добавить ќѕ≈–ј“ќ– данному ¬џ„»—Ћ»“≈Ћё..?
 mOps = 0 -- дл€ суммировани€
 for i=1,subTiers do -- число уже распределЄнных ќѕ≈–ј“ќ–ќ¬ дл€ ¬џ„»—Ћ»“≈Ћя j—alc
  if OpsCalcs[ i ][ mCalc ] ~= 0 then
   mOps = mOps + 1
 end end -- конец for i и if OpsCalcs[ i ][ mCalc ]
--
 if mOps == subTiers then -- надо создавать новый ѕќƒЏя–”—
  subTiers = subTiers + 1
  OpsCalcs[ subTiers ] = {} -- создали новый ѕќƒЏя–”— = строку OpsCalcs[][]
  for jCalc = 1,nCalcs do
   OpsCalcs[ subTiers ][ jCalc ] = 0 -- обнул€ем
  end end -- конец if mOps и for jCalcs
-- при if mOps ~= subTiers добавл€ть ѕќƒЏя–”— не надо..!
 OpsCalcs[ subTiers ][ mCalc ] = iOp -- добавили ќѕ≈–ј“ќ–
--
end -- конец for nOp=1,nOps
--
-- *** готовим печать распределени€ ќѕ≈–ј“ќ–ќ¬ по я–”—јћ ***************************************
--
AddLineToTextFrame( string.format("\n%d €рус (из %d), %d операторов, %d подъ€рус (а/ов) [вычислитель|оператор (%% исп.выч.)]:", 
                                             iTier, nTiers, #Tiers[iTier], subTiers ) )
AddLineToTextFrame( "=======================================================================" ) 
--
for i=1,subTiers do -- по имеющимс€ на данном €русе подъ€русам
 outStr = string.format("под/€рус=%d: ", i)  -- строка дл€ вывода
 calcsUsed = 0 -- сколько вычислителей использовано на этом подъ€русе
 for j=1,nCalcs do -- по ¬џ„»—Ћ»“≈Ћяћ
 if OpsCalcs[i][j] ~= 0 then -- ненулевые (распределЄнные) элементы массива
  outStr = outStr .. string.format("%d|%d  ", j, OpsCalcs[i][j] )
  calcsUsed = calcsUsed + 1 -- сколько ¬џ„»—Ћ»“≈Ћ≈… распределено
 else -- нулевые (нераспределЄнные) элементы
  outStr=outStr .. string.format("%d|-  ",  j )
 end end -- конец if OpsCalcs[i][j] и for j=1,nCalcs
 AddLineToTextFrame( outStr .. string.format(" (%.1f%%)", 100 * calcsUsed / nCalcs ) )   
end -- конец по подъ€русам (for i=1,subTiers)
--
 AddLineToTextFrame( "" ) 
--
calcsUsedTier = 0 -- сколько ¬џ„»—Ћ»“≈Ћ≈… использовано на этом €русе
--
for i=1,subTiers do -- по имеющимс€ на данном €русе подъ€русам
 outStr = ""  -- строка дл€ вывода
 calcsUsedSubTier = 0 -- сколько ¬џ„»—Ћ»“≈Ћ≈… использовано на этом подъ€русе
 for j=1,nCalcs do -- по ¬џ„»—Ћ»“≈Ћяћ
 if OpsCalcs[i][j] ~= 0 then -- ненулевые (распределЄнные) элементы массива
  outStr=outStr .. "X" 
  calcsUsedSubTier = calcsUsedSubTier + 1 -- сколько ¬џ„»—Ћ»“≈Ћ≈… распределено на подъ€русе
 else -- нулевые (нераспределЄнные) элементы
  outStr=outStr .. "~"
 end end -- for j=nCalcs и if OpsCalcs[i][j]
 calcsUsedTier = calcsUsedTier + calcsUsedSubTier / nCalcs
-- вывод статистики по данному подъ€русу и €русу
 if i ~= subTiers then -- это Ќ≈ ѕќ—Ћ≈ƒЌ»… подъ€рус...
  AddLineToTextFrame( outStr .. string.format(" (%.1f%%)", 
                                           100 * calcsUsedSubTier / nCalcs ) )  
 else -- а это какъ раз ѕќ—Ћ≈ƒЌ»…..!
  AddLineToTextFrame( outStr .. string.format(" (%.1f%%); среднее по под/€русам %.1f%%", 
                                           100 * calcsUsedSubTier / nCalcs, 
                                           100 * calcsUsedTier / subTiers ) )  
 end -- конец if i ~= ...
--
end -- конец по подъ€русам (for i=1,subTiers)
--
OpsCalcs = nil -- освободить пам€ть массива 
--
totalSubTiers = totalSubTiers + subTiers -- суммируем общее число подъ€русов
--
calcsUsedAll = calcsUsedAll + calcsUsedTier -- сколько вычислителей задействовано вообще (на всех €русах, доли единицы)
--
SoundPlay("kuku.wav") -- кукушка возвещает, что данный €рус яѕ‘ обсчитан
--
end -- конец по €русам яѕ‘ (по iTier) #################################################
--
Tiers = nil -- освободили пам€ть массива
--
-- *** конец основной программы ******************************************************************************
--
AddLineToTextFrame( string.format("\n-=- ¬сего €русов= %d; подъ€русов= %d; вычислителей использовано (средн.)= %.1f%% -=-", 
                                             nTiers, totalSubTiers, 100*calcsUsedAll / totalSubTiers ) )
--
SoundPlay("rooster.wav") -- петух возвещает, что работа сделана
-- 