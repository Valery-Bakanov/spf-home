//---------------------------------------------------------------------------
//
#include <vcl.h>
#include "stdio.h"
//
#include <Clipbrd.hpp>
#include <IniFiles.hpp>
#include <SysUtils.hpp> // для DeleteFile
#include <io.h> // для chmod
#include <dos.h> // FA_RDONLY + sleep
#include <share.h> // SH_COMPAT
//
#pragma hdrstop
//
#include "Unit1c.h" // чтобы был доступ к F1 (основное окно работы с Lua)
#include "Unit2c.h"
//
// определение констант для всей программы
#define _32    32
#define _64    64
#define _128   128
#define _256   256
#define _512   512
#define _1024  1024
#define _2048  2048
#define _4096  4096
#define _8192  8192
#define _16384 16384
#define _32768 32768
//
//------------------------------------------------------------------------------
//
#pragma package(smart_init)
#pragma resource "*.dfm"
TF2 *F2;
//
#define REAL float // тип вещественных чисел при вычислениях (32 бит)
#define INT  signed long int // тип целых (32 бит)
//
#define ULI unsigned long int // длинное целое без знака (32 бит)
#define UI  unsigned int // целое без знака (32 бит)
//
#define _minINT -1073741824 // минимум -(2^30) и максимум 2^30 int_32
#define _maxINT  1073741824
//
////////////////////////////////////////////////////////////////////////////////
extern const int minW_F2=850, minH_F2=600; // минимальный размер дочерной формы F2
extern char FileNameEdges[]; // имя файла ИГА (определено в Unit1.cpp)
extern void __fastcall PutParamsAboutSelectOp( INT Op ); // определено в Unit1.cpp
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
__fastcall TF2::TF2(TComponent* Owner): TForm(Owner)
{
 F2->Position = poDefault; // чтобы не мешала позиционированию...
/*
 SetWindowLong(Handle, GWL_STYLE, // создать окно без заголовка
               GetWindowLong( Handle, GWL_STYLE ) && (! WS_CAPTION));
 ClientHeight=Height;
*/
} //----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall TF2::M1_PM_ClearAll(TObject *Sender)
{ // очистить M1
 M1->Clear(); // полностью очистить M1 (TMemo)
} //----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall TF2::M1_PM_CopyAll(TObject *Sender)
{ // копировать в Clipboard всё из M1 (TMemo)
// Clipboard->AsText = M1->Text.
 M1->SelectAll(); // выделить весь текст в M1
 M1->CopyToClipboard(); // копировать всё из M1 в Clipboard
 M1->SelLength = 0; // снять выделение
} //----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall TF2::M1_PM_CopyToNotepad(TObject *Sender)
{ // копировать в NotePad всё из M1 (TMemo)
 char tmpFileName[_256];
 strcpy( tmpFileName, ChangeFileExt( FileNameEdges, ".txt" ).c_str()); // имя проекта + "txt"
 M1->Lines->SaveToFile( tmpFileName ); // выдать все строки из M1 в файл tmpFileName
 ShellExecute( Handle, "open", tmpFileName, NULL, NULL, SW_RESTORE ); // открыть файл tmpFileName
//
 sleep( 1 ); // #include <dos.h>
//
 DeleteFile( tmpFileName ); // уничтожить (временный) файл
} //----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall TF2::CopyPictureToClipboard(TObject *Sender)
{ // копирует картинку в Clipboard
//
 try
 {
  Clipboard()->Assign(IM1->Picture); // копировать это в Clipboard
// IM1->Picture->SaveToFile("pict_01.bmp"); // сохранить в файл
  MessageBeep(MB_OK); // it's OK...
 }
 catch(...)
 {
  MessageBeep(MB_ICONEXCLAMATION); // it's no OK...
 }
//
} //---- конец CopyPictureToClipboard ------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall TF2::OnResize_F2(TObject *Sender)
{ // вызывается при изменения размеров F2
 int W = F2->Width, // взяли текущий размер главного окна программы
     H = F2->Height;
// MessageBeep(MB_OK);
//
 if( W < minW_F2 ) // окно не может быть менее minW_F2 * minH_F2
  W = minW_F2;
//
 if( H < minH_F2 ) // ...
  H = minH_F2;
//
// теперь можем установить размеры главного окна и всех подокон
//
 F2->Width  = W; // новый размер окна программы
 F2->Height = H;
//
// внутренние компоненты окна F2
//
 PN1->Left   = F2->Width  - PN1->Width - 20 ; // панель-контейнер графического вывода
 PN1->Height = F2->Height - PN1->Top   - 102 ;
//
 M1->Width  = PN1->Left - M1->Left - 3; // окно текстового вывода (слева сверху)
 M1->Height = PN1->Height; // нижняя граница  одинаковая с PN1
//
 L_GP->Top   = F2->Height - 99; // текст внизу слева
 L_GP->Width = IM_Logo->Left - L_GP->Left - 5 ; // ширина этого текста
//
// L_OM->Left = PN1->Left ; // текст вверху cправа *********************
 L_OM->Left = F2->Width - L_OM->Width - 22; // прав.сторона на 22 px левее F2->Width
//
 IM_Logo->Left = PN1->Left + PN1->Width - IM_Logo->Width ;  // логотип - ГРАФОВЫЖИМаЛКА
 IM_Logo->Top  = PN1->Top  + PN1->Height + 3 ;
//
} //----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void __fastcall TF2::M1_OneClick(TObject *Sender)
{ // одинАрный щелчок мышью на поле M1
 int Col = M1->CaretPos.x, // номер символа в строке, номер строки (начиная с 1)
     Row = M1->CaretPos.y; // определяются координаты левой верхней точки контура символа
//
 char symb;
 char tmp[_32] = "\0";
 INT n0,n1,n2;
//
 n0 = strlen( M1->Lines->Strings[Row].c_str() ); // длина временной строки для обработки строки в M1
 char *str = (char*)malloc( n0+10 ); // выделяем память под временную строку (с запасом)
//
 strcpy(str, M1->Lines->Strings[Row].c_str() ) ; // копируем строку, на которой щёлкнули мышью
//
 symb = str[Col]; // символ СПРАВА от точки щелчка мыши
//
 if( !isdigit( symb ) && // если symb 'не число' И
      isdigit( str[Col-1] ) ) // слева находится число ...
 {
  Col -- ; // мышью была выбрана позиция СПРАВА от числа... перемещаем влево на позицию..!
  symb = str[Col];
 }
//
// начало проверки на номер оператора в строке
 if( !isdigit( symb ) || // символ - не цифра...
      sscanf( str, "%d|%d:", &n1,&n2 ) != 2 ) // в начале нет сочетания 'n1|n2:'
  goto end;
//
 n0 = strchr( str, ':' ) - str ; // номер символа ':' в строке str (начиная с 0)
//
 if( Col <= n0 ) // символ справа от щелчка мыши левее или совпадает с ':'
  goto end;
//
// ищем левую границу числа (номера оператора на ярусе ЯПФ)
 for( INT i=Col-1; i>n0; i-- ) // справа налево от точки щелчка кнопкой мыши
  if( !isdigit( str[i] ) ) // нашли не цифру
  {
   n1 = i+1; // левую границу запомнили в n1
   break;
  }
//
// ищем правую границу числа (номера оператора на ярусе ЯПФ
 n2 = strlen( str ); // ...самое правое число в строке и правее нет символа 'не цифра'
//
 for( INT i=Col; str[i]!='\0'; i++ ) // слева направо от точки щелчка кнопкой мыши до конца строки
  if( !isdigit( str[i] ) ) // нашли не цифру ИЛИ
  {
   n2 = i-1; // левую границу запомнили в n1
   break;
  }
//
 for( INT i=n1; i<=n2; i++ )
  tmp[i-n1] = str[i] ; // символы от n1 до n2 копируем из строки str в строку tmp
 strcat( tmp, "\0" ); // финиширующий ноль
//
 if( sscanf( tmp, "%d", &n0 ) != 1 ) // дополнительная проверка преобразования строки в целое
  goto end;
//
 PutParamsAboutSelectOp( n0 ); // выдать в текстовое окно параметры оператора Op
//
 free( str ); // деаллокируем память под временную строку
 return; // конец успешной обработки
//
end: // конец неудачной обработки
//
 L_GP->Caption = "";
 MessageBeep( MB_ICONEXCLAMATION ); // звуковое предупреждение...
 free( str ); // деаллокируем память под временную строку
//
} //----------------------------------------------------------------------------





