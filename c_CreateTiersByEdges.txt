////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool __fastcall c_CreateTiersByEdges( char* FileName )
{ // создаЄт (на основе »√ј из файла FileName первоначальную (в "верхней" форме)
// - €русно-параллельную форму (яѕ‘) графа в массиве Tiers[][]
// - и вычисл€ет общее количество операторов в информационном графе алгоритма
 INT iOp, fromOp, toOp, i;
 char str[_2048], w[_256];
//
 INT old_nMoves = nMoves; // запомнили значение счЄтчика перемещений операторов с €руса на €рус яѕ‘
//
 if( !c_ReadEdges( FileName ) ) // читаем »√ј-файл в массив Mem_Edges[][]
 {
  flagExistsEdges =
  flagExistsTiers = false;
//
  DisplayMessage( "E", __FUNC__, messNotEdges, ERR_NOT_MASSIVE_EDGES ); // выдать сообщение
  return ERR_NOT_MASSIVE_EDGES ;
 }
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
 _maxTiers     = _maxTiersPrim; // текущие значени€ - без Prim
 _maxOpsOnTier = _maxOpsOnTierPrim;
//
 pTiers = (INT*) realloc( pTiers, (_maxTiersPrim+1) * (_maxOpsOnTierPrim+1) * sizeof(INT) ); // реаллокировали пам€ть под Tiers[][]...
//
 if( pTiers == NULL ) // совсем плохо - пам€ть в "куче" закончилась
 {
  snprintf(str,sizeof(str), "нехватка пам€ти дл€ размещени€ массива Tiers[][] (Prim). «атребовано %d x %d = %d элементов...",
                _maxTiersPrim+1, _maxOpsOnTierPrim+1, (_maxTiersPrim+1) * (_maxOpsOnTierPrim+1));
  flagExistsTiers = false ; // массив Tiers[][] не создан...
  DisplayMessage( "E", __FUNC__, str, ERR_NOT_MASSIVE_TIERS ); // выдать сообщение
  MessageBeep( MB_ICONEXCLAMATION ); // звуковое предупреждение...
  MessageBox(0, str, "ѕредупреждение", MB_OK | MB_ICONWARNING | MB_TOPMOST);
  return ERR_NOT_MASSIVE_TIERS ;
 }
//
 snprintf(str,sizeof(str), "массив Tiers[][] (Prim) перераспределЄн на %d x %d = %d элементов",
               _maxTiersPrim+1, _maxOpsOnTierPrim+1, (_maxTiersPrim+1) * (_maxOpsOnTierPrim+1));
 DisplayMessage( "I", __FUNC__, str, 0 ); // выдать сообщение
//
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//
// --- в Tiers[0][*] помещаем операторы ¬’ќƒЌќ√ќ (нулевого) €руса --------------
// --- это операторы, Ќ≈ »ћ≈ёў»≈ ¬’ќƒќ¬ (только выходы) ------------------------
 Tiers(0,0) = 0; // число операторов ¬’ќƒЌќ√ќ (нулевого) €руса
//
 for(INT iEdges=1; iEdges<=nEdges; iEdges++) // по всем дугам
  for(i=0; i<=1; i++) // по ¬’ќƒяў»ћ и ¬џ’ќƒяў»ћ операторам данной дуги
  {
   iOp = Edges(i,iEdges); // вз€ли номер оператора
   if( !c_GetCountInEdgesByOp( iOp )  &&  // этот оператор не имеет ¬’ќƒяў»’ дуг "»"
       !c_IsOpExistOnTier( iOp, 0 ) ) // iOp Ќ≈ ѕ–»—”“—“¬”≈“ на €русе iTier
   {
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
 if( ( Tiers(0,0) + 3 ) >= _maxOpsOnTier ) // то же, но с ЅоЋ№Ў»ћ запасом
  if( IncreaseOpsOnTier( 0, _maxOpsOnTier * stockMem, 1 ) == false ) // неудача перераспределени€ пам€ти
  {
   flagExistsTiers = false ; // массив Tiers[][] не создан...
   DisplayMessage( "E", __FUNC__, messNotTiers, ERR_NOT_MASSIVE_TIERS ); // выдать сообщение
   return ERR_NOT_MASSIVE_TIERS ;
  }
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
    Tiers(0,0) ++ ; // увеличили на 1 число операторов на ¬’ќƒЌќћ (нулевом) уровне
    Tiers(0, Tiers(0,0)) = Edges(i,iEdges); // запомнили его в столбце Tiers(0,j)
//
   } // конец if
  } // конец цикла по i
// конец цикла по iEdges -------------------------------------------------------
//
////////////////////////////////////////////////////////////////////////////////
// --- начинаем выбирать операторы по €русам начина€ с iTier=1 до ??? ----------
 for(INT iTier=1; iTier<=_maxTiers; iTier++) // пока не знаем, сколько будет €русов...
 {
  Tiers(iTier,0) = 0; // (начальное) число операторов на €русе iTier
// на €русе iTier располагаем операторы, зав»симые по дугам от операторов на
// €русе iTier-1; этих операторов ровно Tiers[iTier-1][0] штук
  for(INT j=1; j<=Tiers(iTier-1,0); j++) // по from-операторам на €русе iTier-1
  {
   fromOp = Tiers(iTier-1,j); // номер fromOp ("от которого" дуга)
// --- ищем в списке дуг to-оператор, по дуге соответствующий from-оператору ---
   for(INT i=1; i<=nEdges; i++) // по всем дугам (св€з€м операторов)
   {
    if( Edges(0,i) == fromOp ) // найдена дуга c from-оператором, соответствующим данному
    {
// --- зависит ли toOp=Mem_Edges[i] ещЄ от каких либо операторов, Ќ≈ Ќј’ќƒяў»’—я
// --- Ќј я–”—ј’ 1 - iTier ? ≈сли зависит - “ј ќ… Ќјћ Ќ≈ ѕќƒ’ќƒ»“ !!!
     toOp = Edges(1,i); // вот от этого зависит fromOp !..
// --- при каких услови€х оператор toOp может быть добавлен на €рус iTier ??????
     if( c_IsOpDependOnlyAboveTiers( toOp, iTier ) && /// если toOp зависит “ќЋ№ ќ
                 // от операторов на ¬џЎ≈Ћ≈∆јў»’ €русах (искл. данный iTier) "»"
        !c_IsOpExistOnTier( toOp, iTier ) ) // Op Ќ≈ ѕ–»—”“—“¬”≈“ на €русе iTier
     {
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
 if( ( Tiers(iTier,0)+1 ) >= _maxOpsOnTier ) // не помещаемс€ в _maxOpsOnTier...
  if( IncreaseOpsOnTier( iTier, _maxOpsOnTier * stockMem, 11 ) == false ) // неудача перераспределени€ пам€ти
  {
   flagExistsTiers = false ; // массив Tiers[][] не создан...
   DisplayMessage( "E", __FUNC__, messNotTiers, ERR_NOT_MASSIVE_TIERS ); // выдать сообщение
   return ERR_NOT_MASSIVE_TIERS ;
  }
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// --- всЄ скопировано - можно продолжать работать уже с новым pTiers ----------
      Tiers(iTier,0) ++ ; // всЄ хорошо, можно увеличивать на 1 число операторов на €русе iTier...
      Tiers(iTier, Tiers(iTier,0) ) = toOp; // в Tiers[iTier][*] соответствующий toOp
     } // конец if (  Is... / Is... )
    } // конец if( Mem_Edges[0][i] == fromOp )
   } // конец цикла по i (списку дуг)
// -----------------------------------------------------------------------------
  } // конец цикла по j (числу операторов на €русе iTier-1)
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// --- анализируем, закончились ли €русы яѕ‘ -----------------------------------
  if( ( Tiers(iTier,0) != 0 ) && // если на €русе iTier есть операторы...
      ( (iTier+1) >= _maxTiers ) ) // а строки массива Tiers[][] заканчиваютс€...
  {
// --- увеличиваем _maxTiers, а _maxOpsInTier оставл€ем тем же самым -----------
// --- в этом случае можно использовать realloc, обеспечивающий сохранность данных
   _maxTiers *= stockMem; // новое число строк с запасом stockMem
//
   pTiers = (INT*) realloc( pTiers,  (_maxTiers+1) * (_maxOpsOnTier+1) * sizeof(INT) ); // захват пам€ти под новый массив
//
   if( pTiers == NULL ) // совсем плохо - пам€ть в "куче" закончилась
   {
    snprintf(str,sizeof(str), "Ќехватка пам€ти дл€ размещени€ массива Tiers[][] (2). «атребовано %d x %d = %d элементов...",
                 _maxTiers+1, _maxOpsOnTier+1, (_maxTiers+1) * (_maxOpsOnTier+1));
    flagExistsTiers = false ; // массив Tiers[][] не создан...
    DisplayMessage( "E", __FUNC__, str, ERR_NOT_MASSIVE_TIERS ); // выдать сообщение
    MessageBeep( MB_ICONEXCLAMATION ); // звуковое предупреждение...
    MessageBox(0, str, "ѕредупреждение", MB_OK | MB_ICONWARNING | MB_TOPMOST);
    return ERR_NOT_MASSIVE_TIERS ;
   } // конец if ( npTiers == NULL )
//
   snprintf(str,sizeof(str), "массив Tiers[][] (2) перераспределЄн на %d x %d = %d элементов",
                 _maxTiers+1, _maxOpsOnTier+1, (_maxTiers+1) * (_maxOpsOnTier+1));
   DisplayMessage( "E", __FUNC__, str, ERR_NOT_MASSIVE_TIERS ); // выдать сообщение
  }  // конец if ( Tiers(iTier,0) != 0 && ...
//
// --- всЄ скопировано - можно продолжать работать уже с новым pTiers ----------
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
  if( Tiers(iTier,0) == 0 ) // не найдено ни одного to-оператора на €русе iTier
  {
   nTiers = iTier - 1 ; // запомнили число €русов
   break; // на этом €русе нет to-операторов... €русы кончились... выбрасываемс€ из цикла!
  } // заполнено iTier-1
////////////////////////////////////////////////////////////////////////////////
//
 } // конец цикла по iTier (€русам яѕ‘) ========================================
//
////////////////////////////////////////////////////////////////////////////////
  nOps = 0; // общее число операторов Ѕ≈« ¬’ќƒЌџ’ (глобальное)
// --- вычисл€ем cуммарное количество операторов (суммируем по €русам яѕ‘) -----
 for(INT iTier=1; iTier<=nTiers; iTier++) // по числу €русов яѕ‘ кроме ¬’ќƒЌќ√ќ (нулевого)
  nOps += Tiers(iTier,0);
//
////////////////////////////////////////////////////////////////////////////////
//
 flagExistsTiers = true ; // признак того, что яѕ‘ построена
//
 TestExistInOutAtAllOps(); // тестирование входов и выходов
//
 nOpsInput  = Tiers( 0, 0 ); // число ¬’ќƒЌџ’ вершин (операторов)
 nOpsOutput = Tiers( nTiers, 0 ); // число ¬џ’ќƒЌџ’ вершин (операторов)
//
 t_printf( "\n-I- %s(): яѕ‘ графа в \"верхней\" форме по файлу [%s] успешно построена -I-", __FUNC__, FileNameEdges );
//
 flagExistsTiers = true ; // массив Tiers[][] сформирован..!
//
 flagCalcTLD = false ; // paramsTLD не соответствует Tiers[][]
//
 if( F1->N5->Checked ) // если включЄн режим "приземлени€" всех всех выходных операторов...
  OutOpsMoveLowerTier(); // все выходные операторы перенести на самый нижний €рус
//
 nMoves = old_nMoves; // восстановили значение счЄтчика перемещений операторов с €руса на €рус яѕ‘
//
 return true ; // всЄ нормально - массив Tiers[][] в "верхней" форме построен
//
} // --- конец c_CreateTiersByEdges---------------------------------------------
